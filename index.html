<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 ç©æ³•å®éªŒå®¤ (æ— å°½æ¨¡å¼ç‰ˆ)</title>
    <meta name="color-scheme" content="light only">
    <style>
        /* --- 1. åŸºç¡€è§†è§‰é£æ ¼ --- */
        :root {
            --bg-color: #faf8ef;
            --text-color: #776e65;
            --board-bg: #bbada0;
            --cell-empty: #cdc1b4;
            --btn-bg: #8f7a66;
            --btn-text: #f9f6f2;
            color-scheme: light;
            
            /* åŠ¨æ€å˜é‡ */
            --grid-size: 4; 
            --tile-font-size: 30px; 

            /* é¢œè‰²é…ç½® */
            --hp-fill: #e74c3c;
            --enemy-color: #c0392b;
            --potion-color: #2ecc71;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            overflow-x: hidden;
        }

        /* --- é¡¶éƒ¨å¯¼èˆªæ  --- */
        .top-bar {
            width: 100%; 
            max-width: 600px;
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            padding: 10px 20px; 
            background: rgba(255,255,255,0.8);
            backdrop-filter: blur(5px);
            z-index: 100;
            height: 60px;
            position: sticky;
            top: 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .icon-btn {
            font-size: 16px; cursor: pointer; padding: 8px 16px;
            background: #fff; border: 2px solid #eee4da; border-radius: 20px; 
            color: var(--text-color); display: flex; align-items: center; gap: 6px;
            font-weight: bold; transition: background 0.1s;
        }
        .icon-btn:active { background: #e0e0e0; transform: scale(0.95); }
        .icon-btn span { pointer-events: none; }

        /* --- è®¾ç½®å¼¹çª— --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex; justify-content: center; align-items: center;
            z-index: 9999;
            opacity: 0; pointer-events: none; transition: opacity 0.2s;
        }
        .modal.active { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: #fff; padding: 25px; border-radius: 12px; width: 85%; max-width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
        }
        .setting-row { margin-bottom: 20px; text-align: left; }
        .setting-row label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
        .setting-row select { width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #ccc; font-size: 16px; background: #fff; }
        .close-btn { width: 100%; background: var(--btn-bg); color: white; border: none; padding: 12px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; }

        /* --- é€šç”¨å®¹å™¨ --- */
        .screen { 
            width: 100%; 
            flex: 1;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 10px;
            padding-bottom: 50px;
        }
        .hidden { display: none !important; }

        /* --- æ¨¡å¼é€‰æ‹©å¡ç‰‡ --- */
        .mode-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 100%;
            max-width: 500px;
            margin-bottom: 20px;
        }

        .mode-card {
            background: #fff;
            border: 2px solid #eee4da;
            border-radius: 12px;
            padding: 20px 10px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: transform 0.1s, background-color 0.1s;
        }
        .mode-card:active { transform: scale(0.96); background-color: #f0f0f0; border-color: var(--btn-bg); }
        .mode-card > * { pointer-events: none; }
        .mode-card h3 { margin: 8px 0; font-size: 18px; color: #555; }
        .mode-card p { margin: 0; font-size: 13px; color: #999; }
        .mode-icon { font-size: 32px; margin-bottom: 5px; }

        /* --- æ¸¸æˆå¤´éƒ¨ --- */
        .header-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin-bottom: 10px;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .stat-group { display: flex; gap: 10px; }
        .stat-box {
            background: #bbada0;
            padding: 5px 15px;
            border-radius: 6px;
            color: white;
            text-align: center;
            min-width: 70px;
        }
        .stat-title { font-size: 12px; text-transform: uppercase; opacity: 0.9; }
        .stat-value { font-size: 20px; font-weight: bold; }

        /* AI é€Ÿåº¦æ§åˆ¶æ¡ */
        #ai-controls {
            background: rgba(255,255,255,0.7);
            padding: 5px 10px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            border: 1px solid #ccc;
        }
        #ai-speed-slider { width: 80px; accent-color: var(--btn-bg); }

        /* RPGè¡€æ¡ */
        .hp-container {
            width: 100%; max-width: 500px;
            height: 12px; background: #ddd; border-radius: 6px; margin-bottom: 5px; overflow: hidden; display: none;
        }
        .hp-fill { height: 100%; background: var(--hp-fill); width: 100%; transition: width 0.3s ease; }

        /* --- æ ¸å¿ƒï¼šæ¸¸æˆæ£‹ç›˜ --- */
        #game-board-container {
            width: min(92vw, 500px);
            aspect-ratio: 1 / 1;
            position: relative;
            margin-top: 5px;
            touch-action: none;
        }

        #game-board {
            background-color: var(--board-bg);
            border-radius: 8px;
            padding: 10px;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(var(--grid-size, 4), 1fr);
            grid-template-rows: repeat(var(--grid-size, 4), 1fr);
            gap: 8px;
            box-sizing: border-box;
            position: relative;
        }

        .tile {
            background-color: var(--cell-empty);
            border-radius: 6px;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: var(--tile-font-size);
            position: relative;
            transition: transform 0.1s;
        }

        .tile-inner {
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            border-radius: 4px;
            animation: appear 0.2s ease-in;
            color: #f9f6f2;
        }
        
        /* é¢œè‰²è¡¨ */
       .val-2 { background: #eee4da; color: #776e65; }
       .val-4 { background: #ffe082; color: #776e65; }
       .val-8 { background: #ff9800; color: #fff; }
       .val-16 { background: #f59563; }
       .val-32 { background: #f67c5f; }
       .val-64 { background: #f65e3b; }
       .val-128 { background: #edcf72; font-size: calc(var(--tile-font-size) * 0.8); }
       .val-256 { background: #edcc61; font-size: calc(var(--tile-font-size) * 0.8); }
       .val-512 { background: #edc850; font-size: calc(var(--tile-font-size) * 0.8); }
       .val-1024 { background: #edc53f; font-size: calc(var(--tile-font-size) * 0.6); }

        /* ç‰¹æ®Šæ–¹å— */
        .type-enemy { background: var(--enemy-color) !important; border: 2px solid #a93226; box-sizing: border-box; }
        .type-potion { background: var(--potion-color) !important; font-size: calc(var(--tile-font-size) * 1.2); }

        /* AI æŒ‡ç¤ºç®­å¤´ */
        #ai-arrow {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: rgba(231, 76, 60, 0.8);
            z-index: 20;
            pointer-events: none;
            display: none;
            text-shadow: 0 0 10px white;
            animation: float 1s infinite;
        }
        @keyframes float { 0%,100%{ opacity: 0.5; } 50%{ opacity: 1; } }

        /* --- 5. ç‰©ç†å°„å‡»æ¨¡å¼é€‚é… --- */
        #physics-stage {
            width: min(92vw, 400px);
            height: min(138vw,600px);
            background: #2c3e50;
            position: relative;
            border-radius: 10px; overflow: hidden;
            border: 4px solid #34495e;
            touch-action: none;
            cursor: crosshair;
            margin: 0 auto 20px auto;
        }
        .phy-block {
            position: absolute; width: 60px; height: 60px;
            border-radius: 10px;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 24px; color: white;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 10;
        }
        .aim-line {
            position: absolute; width: 0; height: 0;
            border-left: 2px dashed rgba(255,255,255,0.5);
            top: 0; pointer-events: none; display: none; z-index: 5; transform-origin: top center;
        }

        /* åŠ¨ç”»ä¸é®ç½© */
        @keyframes appear { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        
        .overlay {
            position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: rgba(250, 248, 239, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 50;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        
        button {
            background: var(--btn-bg); color: #fff; border: none; padding: 12px 24px; 
            border-radius: 6px; font-size: 16px; cursor: pointer; margin: 8px;
            font-weight: bold;
        }
        button:active { background: #736252; transform: scale(0.95); }

        /* æ–°å¢è­¦æˆ’çº¿æ ·å¼ */
        #limit-line {
            position: absolute;
            width: 100%;
            height: 2px;
            border-top: 2px dashed #e74c3c; /* çº¢è‰²è™šçº¿ */
            left: 0;
            z-index: 5;
            pointer-events: none; 
        }

        .shooter-area {
            background: rgba(0, 0, 0, 0.1); 
        }

/* --- æ–°å¢ï¼šé”å®šæ¨¡å¼æ ·å¼ --- */
.mode-card.locked {
    opacity: 0.5;
    filter: grayscale(100%);
    cursor: not-allowed;
    position: relative;
}
.mode-card.locked::after {
    content: "ğŸ”’";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 40px;
    opacity: 0.8;
}

/* --- æ–°å¢ï¼šç‰ˆæƒä¿¡æ¯æ ·å¼ --- */
.copyright-footer {
    margin-top: auto; /* è‡ªåŠ¨æ¨åˆ°å®¹å™¨åº•éƒ¨ */
    padding: 20px 0;
    font-size: 12px;
    color: #999;     /* ç°è‰²æ–‡å­—ï¼Œä¸åˆºçœ¼ */
    text-align: center;
    line-height: 1.6;
    width: 100%;
}
.copyright-footer a {
    color: #8f7a66;
    text-decoration: none;
    border-bottom: 1px dashed #8f7a66;
}

    </style>
</head>
<body>

    <!-- é¡¶éƒ¨å¯¼èˆª -->
    <div class="top-bar">
        <h2 style="margin:0; font-size: 20px; color: #776e65; font-weight: bold;">2048ç©æ³•å®éªŒå®¤</h2>
        <button class="icon-btn" onclick="window.ui.toggleSettings()">
            <span style="font-size: 18px;">âš™ï¸</span>
            <span>è®¾ç½®</span>
        </button>
    </div>

    <!-- è®¾ç½®å¼¹çª— -->
    <div class="modal" id="settings-modal">
        <div class="modal-content">
            <h3 style="margin-top:0; text-align: center; color: #776e65;">æ¸¸æˆè®¾ç½®</h3>
            <div class="setting-row">
                <label>èƒŒæ™¯éŸ³ä¹ (BGM)</label>
                <select id="bgm-select" onchange="window.audioManager.changeBGM(this.value)">
                </select>
            </div>
            <div class="setting-row">
                <label>éŸ³æ•ˆ (SFX)</label>
                <select id="sfx-select" onchange="window.audioManager.changeSFX(this.value)">
                </select>
            </div>
            <button class="close-btn" onclick="window.ui.toggleSettings()">å®Œæˆ</button>
        </div>
    </div>

    <!-- æ¨¡å¼é€‰æ‹©ç•Œé¢ -->
    <div id="start-screen" class="screen">
        <h1 style="font-size: 28px; color: #776e65; margin-bottom: 5px;">é€‰æ‹©æ¸¸æˆæ¨¡å¼</h1>
        <p style="color: #999; margin-bottom: 25px; font-size: 14px;">ç‚¹å‡»å¡ç‰‡å¼€å§‹æŒ‘æˆ˜</p>
        
        <div class="mode-grid">
            <div class="mode-card" onclick="window.game.start('classic')">
                <span class="mode-icon">ğŸ”¢</span>
                <h3>ç»å…¸æ¨¡å¼</h3>
                <p>4x4 åŸæ±åŸå‘³</p>
            </div>            
            <div class="mode-card" onclick="window.game.start('rpg')">
                <span class="mode-icon">âš”ï¸</span>
                <h3>RPG2048</h3>
                <p>4x4 æ‰“æ€ªå—‘è¯å‡çº§</p>
            </div>
            <div class="mode-card" onclick="window.game.start('gravity')">
                <span class="mode-icon">ğŸ</span>
                <h3>é‡åŠ›2048</h3>
                <p>åªèƒ½ä¸‹è½ã€å·¦å³ç§»åŠ¨</p>
            </div>
            <div class="mode-card" onclick="window.game.start('ap')">
                <span class="mode-icon">ğŸ‘£</span>
                <h3>æ­¥æ­¥ä¸ºèµ¢2048</h3>
                <p>æ­¥æ•°æœ‰é™ï¼Œä¸‰æ€åè¡Œ</p>
            </div>
            <div class="mode-card" onclick="window.game.start('city')">
                <span class="mode-icon">âš¡</span>
                <h3>å‡¡äººä¿®ä»™2048</h3>
                <p>å‡¡äººä¿®ä»™ï¼Œé€†å¤©æ”¹å‘½</p>
            </div>
            <div class="mode-card" onclick="window.game.start('shoot')">
                <span class="mode-icon">ğŸ¹</span>
                <h3>æ³¡æ³¡é¾™2048</h3>
                <p>å°„å‡»ç¢°æ’ç©æ³•</p>
            </div>
            <!-- ä¿®æ”¹ï¼šå°†è´ªé£Ÿè›‡æ¨¡å¼æ”¹ä¸ºæ— å°½æ¨¡å¼ -->
            <div class="mode-card" onclick="window.game.endlessSetup()">
                <span class="mode-icon">âˆ</span>
                <h3>æ— å°½æ¨¡å¼</h3>
                <p>4x4 åˆ° 9x9 è‡ªé€‰ï¼Œæ— æ­¢å¢ƒ</p>
            </div>
	    <div class="mode-card" id="ai-card">
                <span class="mode-icon">ğŸ¤–</span>
                <h3>AI æ¼”ç¤º</h3>
                <p>çœ‹AIå¦‚ä½•ç©è½¬2048</p>
            </div>
	<div class="copyright-footer">
        Â© 2026 Taby-Ding. All Rights Reserved. <br>
	 Based on 2048 by Gabriele Cirulli.<br>
                <span style="font-size: 10px; opacity: 0.6;">v2.0 AIå¢å¼ºç‰ˆ</span>
    </div>
        </div>
    </div>

    <!-- æ¸¸æˆä¸»ç•Œé¢ -->
    <div id="game-screen" class="screen hidden">
        <div class="header-bar">
            <button onclick="window.game.showMenu()" style="font-size:14px; padding:8px 15px;">â¬… èœå•</button>
            <div class="stat-group">
                <div class="stat-box">
                    <div class="stat-title">å¾—åˆ†</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <!-- ç‰¹æ®ŠçŠ¶æ€æ  -->
                <div class="stat-box" id="moves-box" style="display:none;">
                    <div class="stat-title">æ­¥æ•°</div>
                    <div class="stat-value" id="moves">50</div>
                </div>
                <!-- AI æ§åˆ¶æ¡ -->
                <div id="ai-controls" style="display:none;">
                    <span>AIé€Ÿåº¦:</span>
                    <input type="range" id="ai-speed-slider" min="1" max="10" step="1" value="5" title="è¶Šå³è¶Šå¿«">
                </div>
            </div>
        </div>

        <!-- RPGè¡€æ¡ -->
        <div class="hp-container" id="hp-bar">
            <div class="hp-fill" id="hp-fill" style="width: 100%;"></div>
        </div>
        <div id="hp-text" style="font-size: 13px; color: #e74c3c; margin-bottom: 8px; font-weight: bold; display:none;">HP: 100/100</div>

        <!-- 1. ç½‘æ ¼æ¸¸æˆåŒºåŸŸ (RPG/Classic/City...) -->
        <div id="game-board-container">
            <div id="game-board">
                <!-- AIæŒ‡ç¤ºç®­å¤´ -->
                <div id="ai-arrow">â¬†ï¸</div>
                <!-- æ¸¸æˆåŒºåŸŸ -->
                <div class="overlay" id="overlay">
                    <h2 id="overlay-msg" style="font-size: 32px; color: #776e65; margin: 10px;">Game Over</h2>
                    <div id="overlay-desc" style="margin-bottom: 20px; color: #999;"></div>
                    <button onclick="window.game.restartGrid()">å†è¯•ä¸€æ¬¡</button>
                    <button onclick="window.game.showMenu()">ä¸»èœå•</button>
                </div>
            </div>            
        </div>
<p id="game-tip" style="margin-top: 15px; font-size: 14px; color: #aaa; text-align: center; max-width: 90%;"></p>

        <!-- 2. ç‰©ç†å°„å‡»æ¸¸æˆå®¹å™¨ -->
        <div id="physics-stage" style="display:none;">
            <div id="limit-line"></div> 
            <div class="aim-line" id="aim-line"></div>
            <div class="shooter-area"></div>
            <div class="overlay" id="phy-overlay">
                <h2>å †æ»¡å•¦!</h2>
                <div id="phy-overlay-desc" style="margin-bottom: 20px; color: #999;"></div>
                <button onclick="window.game.restartPhysics()">é‡ç©</button>
                <button onclick="window.game.showMenu()">è¿”å›èœå•</button>
            </div>
        </div>

    </div>

    <script>
        window.addEventListener('load', function() {

// --- æ£€æŸ¥AIæ¨¡å¼è§£é”çŠ¶æ€ ---
    window.checkAIUnlock = function() {
        const isUnlocked = localStorage.getItem('ai_unlocked') === 'true';
        const aiCard = document.getElementById('ai-card');
        if (!aiCard) return;
        const aiText = aiCard.querySelector('p');

        if (isUnlocked) {
            aiCard.classList.remove('locked');
            aiText.innerText = "çœ‹AIå¦‚ä½•ç©è½¬2048";
            // è§£é”åç»‘å®šç‚¹å‡»äº‹ä»¶
            aiCard.onclick = function() { window.game.start('auto_demo'); };
        } else {
            aiCard.classList.add('locked');
            aiText.innerText = "çœ‹AIå¦‚ä½•ç©è½¬2048ï¼Œé€šå…³ä»»æ„æ¨¡å¼è§£é”";
            // é”å®šæ—¶ç‚¹å‡»æç¤º
            aiCard.onclick = function() { alert("ğŸ”’ è¯·å…ˆé€šå…³ä»»æ„æ¨¡å¼ (åˆæˆ2048) åè§£é”æ­¤åŠŸèƒ½ï¼"); };
        }
    }
    window.checkAIUnlock(); // é¡µé¢åŠ è½½æ—¶å…ˆæ£€æŸ¥ä¸€æ¬¡

            // --- 1. å…¨å±€é…ç½® ---
            const AUDIO_CONFIG = {
                bgmList: [
                    { name: "é»˜è®¤éŸ³ä¹", file: "default.mp3" },                    
 		            { name: "RPG", file: "Ukulele.mp3" },
		            { name: "ä¿„ç½—æ–¯æ–¹å—", file: "Tetris.mp3" },
		            { name: "æ­¥æ­¥ä¸ºèµ¢", file: "step.mp3" },		  
                   	    { name: "å‡¡äººä¿®ä»™",   file: "xian.mp3" },
		            { name: "æ³¡æ³¡é¾™", file: "Bubbly.mp3" },
  			    { name: "ç¦…æ„", file: "Zen.mp3" },
			    { name: "ç¦…æ„ï¼ˆé›¨ï¼‰", file: "Zenrain.mp3" },
	   	            { name: "æ— éŸ³ä¹", file: "1.mp3" }
                ],
                sfxList: [
                  	    { name: "é»˜è®¤éŸ³æ•ˆ", file: "coin.mp3" },
                  	    { name: "æŒ¥å‰‘",   file: "sword.mp3" },
		            { name: "å†°å—",   file: "ice.mp3" },	 	           
                 	    { name: "æ¿€å…‰",   file: "laser.mp3" },
	     	            { name: "æ³¡æ³¡", file: "pop.mp3" },
			    { name: "æœ¨é±¼",   file: "muyu.mp3" },
 			    { name: "ç£¬",   file: "chime.mp3" },
		            { name: "æ— éŸ³æ•ˆ", file: "2.mp3" }
                ]
            };

            const CONFIG = {
                classic: { size: 4, tip: "ç»å…¸ç©æ³•ï¼Œåˆæˆ2048è·èƒœã€‚" },
                auto_demo: { size: 4, tip: "ğŸ¤– AI æ­£åœ¨è‡ªåŠ¨æ¼”ç¤ºã€‚è°ƒèŠ‚æ»‘æ†å¯æ”¹å˜æ€è€ƒé€Ÿåº¦ã€‚" },
                rpg:     { size: 4, tip: "ğŸ’€æ˜¯æ€ªç‰©ï¼ŒğŸ’Šå›è¡€ã€‚è‹±é›„æ•°å€¼ >= æ€ªç‰©æ‰èƒ½å‡»æ€å‡çº§ï¼Œå¦åˆ™æ‰£è¡€ï¼" },
                gravity: { size: 4, tip: "é‡åŠ›å¼‚å¸¸ï¼åªèƒ½å‘å·¦ã€å³ã€ä¸‹æ»‘åŠ¨ã€‚" },
                ap:      { size: 4, tip: "æ·±æ€ç†Ÿè™‘ï¼æ¯èµ°ä¸€æ­¥æ¶ˆè€—1ç‚¹æ­¥æ•°ï¼Œåˆæˆ8ä»¥ä¸Šï¼Œæ¯8ç‚¹å›å¤1ç‚¹æ­¥æ•°ã€‚" },
                city:    { size: 4, tip: " å‡¡äººâ†’ç‚¼æ°”â†’ç­‘åŸºâ†’é‡‘ä¸¹â†’å…ƒå©´â†’ åŒ–ç¥â†’ç‚¼è™šâ†’åˆä½“â†’å¤§ä¹˜ â†’æ¸¡åŠ«â†’çœŸä»™" },
                shoot:   { size: 0, tip: "æ‹–åŠ¨ç„å‡†ï¼Œæ¾æ‰‹å°„å‡»ï¼" },
                endless: { size: 0, tip: "æ— å°½æŒ‘æˆ˜ï¼æ²¡æœ‰ç»ˆç‚¹ï¼Œç›´åˆ°å¡«æ»¡ä¸ºæ­¢ã€‚" } // æ–°å¢é…ç½®
            };

            const CITY_NAMES = { 
               2: "å‡¡äºº", 4: "ç‚¼æ°”", 8: "ç­‘åŸº", 16: "é‡‘ä¸¹", 32: "å…ƒå©´", 64: "åŒ–ç¥", 128: "ç‚¼è™š", 
               256: "åˆä½“", 512: "å¤§ä¹˜", 1024: "æ¸¡åŠ«", 2048: "çœŸä»™"
            };

            const COLOR_MAP = {
                2: "#eee4da", 4: "#ffe082", 8: "#ff9800", 16: "#f59563", 32: "#f67c5f",
                64: "#f65e3b", 128: "#edcf72", 256: "#edcc61", 512: "#edc850", 1024: "#edc53f", 2048: "#09f"
            };

            // --- 2. éŸ³é¢‘ç®¡ç†å™¨ ---
            class AudioManager {
                constructor() {
                    this.bgm = new Audio();
                    this.bgm.loop = true;
                    this.sfx = new Audio();
                    this.bgmPath = 'bgm/';
                    this.sfxPath = 'sfx/';
                    this.initUI();
                    if(AUDIO_CONFIG.bgmList.length > 0) this.changeBGM(AUDIO_CONFIG.bgmList[0].file);
                    if(AUDIO_CONFIG.sfxList.length > 0) this.changeSFX(AUDIO_CONFIG.sfxList[0].file);
                    document.body.addEventListener('click', () => { if (this.bgm.paused) this.bgm.play().catch(e=>{}); }, { once: true });
                }
                initUI() {
                    const bgmSelect = document.getElementById('bgm-select');
                    const sfxSelect = document.getElementById('sfx-select');
                    if(bgmSelect) {
                        bgmSelect.innerHTML = "";
                        AUDIO_CONFIG.bgmList.forEach(item => {
                            const opt = document.createElement('option');
                            opt.value = item.file; opt.innerText = item.name;
                            bgmSelect.appendChild(opt);
                        });
                    }
                    if(sfxSelect) {
                        sfxSelect.innerHTML = "";
                        AUDIO_CONFIG.sfxList.forEach(item => {
                            const opt = document.createElement('option');
                            opt.value = item.file; opt.innerText = item.name;
                            sfxSelect.appendChild(opt);
                        });
                    }
                }
                changeBGM(filename) { this.bgm.src = this.bgmPath + filename; this.bgm.play().catch(e=>{}); }
                changeSFX(filename) { this.sfx.src = this.sfxPath + filename; }
                playSFX() { try { const sound = this.sfx.cloneNode(); sound.play().catch(e=>{}); } catch(e){} }
            }
            
            // --- 3. UI æ§åˆ¶ ---
            window.ui = {
                toggleSettings: () => {
                    const modal = document.getElementById('settings-modal');
                    if(modal) modal.classList.toggle('active');
                }
            };

            // --- 5. ç‰©ç†å°„å‡»æ¸¸æˆé€»è¾‘ ---
            class PhysicsGame {
                constructor() {
                    this.stage = document.getElementById('physics-stage');
                    this.width = 0; 
                    this.height = 0;
                    this.blocks = [];
                    this.currentBlock = null;
                    this.isAiming = false;
                    this.animationId = null;
                    this.score = 0;
                    this.blockSize = 60;
                    this.stage.addEventListener('pointerdown', e => this.onDragStart(e));
                    this.stage.addEventListener('pointermove', e => this.onDragMove(e));
                    this.stage.addEventListener('pointerup', e => this.onDragEnd(e));
                    this.stage.addEventListener('pointerleave', e => this.onDragEnd(e));
                }
                start() {
                    this.stage.style.display = 'block';
                    document.getElementById('game-board-container').style.display = 'none';
                    document.getElementById('hp-bar').style.display = 'none';
                    document.getElementById('hp-text').style.display = 'none';
                    document.getElementById('moves-box').style.display = 'none';
                    document.getElementById('ai-controls').style.display = 'none';
                    document.getElementById('game-tip').innerText = CONFIG['shoot'].tip;
                    this.width = this.stage.clientWidth;
                    this.height = this.stage.clientHeight;
                    this.spawnY = this.height - 70; 
                    this.limitY = this.spawnY - 80; 
                    const limitEl = document.getElementById('limit-line');
                    if(limitEl) limitEl.style.top = this.limitY + "px";
                    this.restart();
                }
                restart() {
                    this.blocks = [];
                    this.score = 0;
                    this.updateScore(0);
                    document.getElementById('phy-overlay').classList.remove('active');
                    const oldBlocks = document.querySelectorAll('.phy-block');
                    oldBlocks.forEach(b => b.remove());
                    if (this.animationId) cancelAnimationFrame(this.animationId);
                    this.spawnBlock();
                    this.loop();
                }
                updateScore(val) { this.score = val; document.getElementById('score').innerText = this.score; }
                spawnBlock() {
                    const val = Math.random() < 0.7 ? 2 : 4;
                    const el = document.createElement('div');
                    el.className = `phy-block val-${val}`;
                    el.innerText = val;
                    this.stage.appendChild(el);
                    this.currentBlock = { el: el, val: val, x: this.width / 2 - this.blockSize / 2, y: this.spawnY, vx: 0, vy: 0, state: 'ready' };
                    this.updateEl(this.currentBlock);
                }
                onDragStart(e) {
                    if (!this.currentBlock || this.currentBlock.state !== 'ready') return;
                    this.isAiming = true;
                    this.stage.setPointerCapture(e.pointerId);
                    this.onDragMove(e);
                }
                onDragMove(e) {
                    if (!this.isAiming || !this.currentBlock) return;
                    const rect = this.stage.getBoundingClientRect();
                    let x = e.clientX - rect.left - this.blockSize/2;
                    x = Math.max(0, Math.min(this.width - this.blockSize, x));
                    this.currentBlock.x = x;
                    this.updateEl(this.currentBlock);
                    const line = document.getElementById('aim-line');
                    line.style.display = 'block';
                    line.style.left = (x + this.blockSize/2) + 'px';
                    line.style.height = (this.currentBlock.y) + 'px';
                }
                onDragEnd(e) {
                    if (!this.isAiming) return;
                    this.isAiming = false;
                    document.getElementById('aim-line').style.display = 'none';
                    if (this.currentBlock) {
                        this.currentBlock.state = 'moving';
                        this.currentBlock.vy = -18;
                        this.blocks.push(this.currentBlock);
                        this.currentBlock = null;
                        if(window.audioManager) window.audioManager.playSFX();
                        setTimeout(() => this.spawnBlock(), 600);
                    }
                }
                loop() { this.updatePhysics(); this.animationId = requestAnimationFrame(() => this.loop()); }
                updatePhysics() {
                    for (let i = 0; i < this.blocks.length; i++) {
                        let b = this.blocks[i];
                        if (b.state === 'ready') continue;
                        b.x += b.vx; b.y += b.vy;
                        b.vx *= 0.98; b.vy *= 0.98;
                        if (b.x <= 0) { b.x = 0; b.vx *= -0.6; }
                        if (b.x >= this.width - this.blockSize) { b.x = this.width - this.blockSize; b.vx *= -0.6; }
                        if (b.y <= 0) { b.y = 0; b.vy *= -0.6; }
                        for (let j = i + 1; j < this.blocks.length; j++) {
                            let other = this.blocks[j];
                            if (this.checkCollision(b, other)) {
                                if (b.val === other.val) { this.merge(b, other); i--; break; } else { this.resolveCollision(b, other); }
                            }
                        }
                        if (b.state !== 'ready' && Math.abs(b.vy) < 0.2 && Math.abs(b.vx) < 0.2) {
                            if (b.state === 'moving') b.state = 'static'; 
                            if (b.y+ this.blockSize> this.limitY) { 
                                document.getElementById('phy-overlay').classList.add('active');
                                document.getElementById('phy-overlay-desc').innerText = `å †ç§¯è¿‡çº¿ï¼æœ€ç»ˆå¾—åˆ†: ${this.score}`;
                                cancelAnimationFrame(this.animationId);
                                return;
                            }
                        }
                        this.updateEl(b);
                    }
                }
                checkCollision(a, b) { return (a.x < b.x + this.blockSize && a.x + this.blockSize > b.x && a.y < b.y + this.blockSize && a.y + this.blockSize > b.y); }
                resolveCollision(b1, b2) {
                    let cx1 = b1.x + this.blockSize/2, cy1 = b1.y + this.blockSize/2;
                    let cx2 = b2.x + this.blockSize/2, cy2 = b2.y + this.blockSize/2;
                    let dx = cx1 - cx2, dy = cy1 - cy2;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist === 0) { dx = 0.1; dist = 0.1; }
                    let overlap = this.blockSize - dist;
                    if (overlap > 0) {
                        let nx = dx / dist, ny = dy / dist;
                        b1.x += nx * overlap * 0.5; b1.y += ny * overlap * 0.5;
                        b2.x -= nx * overlap * 0.5; b2.y -= ny * overlap * 0.5;
                        b1.vx += nx * 2; b1.vy += ny * 2;
                        b2.vx -= nx * 2; b2.vy -= ny * 2;
                    }
                }
                merge(target, source) {
                    target.val *= 2;
                    target.el.innerText = target.val;
                    target.el.className = `phy-block val-${target.val > 2048 ? 2048 : target.val}`;
                    target.el.style.transform = `scale(1.3)`;
                    setTimeout(() => target.el.style.transform = `scale(1)`, 150);
                    source.el.remove();
                    this.blocks = this.blocks.filter(x => x !== source);
                    this.updateScore(this.score + target.val);
                    if(window.audioManager) window.audioManager.playSFX();
                    target.vy = -5;
                }
                updateEl(b) { b.el.style.left = b.x + 'px'; b.el.style.top = b.y + 'px'; }
            }

            // --- 6. Gridæ¸¸æˆé€»è¾‘ (å«AIæ‰©å±• + æ— å°½æ¨¡å¼ä¿®æ”¹) ---
            class GridGame {
                constructor() {
                    this.grid = []; 
                    this.score = 0;
                    this.mode = 'classic';
                    this.size = 4;
                    this.isOver = false;
                    this.hp = 100;
                    this.maxHp = 100;
                    this.moves = 0;
                    this.aiTimer = null;
                }

                start(mode, customSize = null) {
                    this.mode = mode;
                    // å¦‚æœä¼ å…¥äº†è‡ªå®šä¹‰å¤§å°ï¼Œåˆ™ä½¿ç”¨è‡ªå®šä¹‰å¤§å°ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤é…ç½®
                    this.size = customSize || CONFIG[mode].size;
                    
                    document.getElementById('game-tip').innerText = CONFIG[mode].tip;
                    
                    document.getElementById('game-board-container').style.display = 'block';
                    document.getElementById('physics-stage').style.display = 'none';
                    
                    const board = document.getElementById('game-board');
                    board.style.setProperty('--grid-size', this.size);
                    
                    // åŠ¨æ€è°ƒæ•´å­—ä½“å¤§å°é€‚é…ä¸åŒç½‘æ ¼
                    let fontSize = '35px';
                    if(this.size === 5) fontSize = '28px';
                    if(this.size === 6) fontSize = '22px';
                    if(this.size === 7) fontSize = '18px';
                    if(this.size === 8) fontSize = '16px';
                    if(this.size === 9) fontSize = '14px';
                    board.style.setProperty('--tile-font-size', fontSize);
                    
                    this.hp = 100; this.moves = 50; this.score = 0;
                    
                    document.getElementById('hp-bar').style.display = (mode === 'rpg') ? 'block' : 'none';
                    document.getElementById('hp-text').style.display = (mode === 'rpg') ? 'block' : 'none';
                    document.getElementById('moves-box').style.display = (mode === 'ap') ? 'block' : 'none';
                    document.getElementById('ai-controls').style.display = (mode === 'auto_demo') ? 'flex' : 'none';
                    document.getElementById('ai-arrow').style.display = 'none';

                    if(this.aiTimer) clearTimeout(this.aiTimer);
                    this.restart();

                    if(mode === 'auto_demo') {
                        this.aiLoop();
                    }
                }

                restart() {
                    this.grid = Array(this.size * this.size).fill(null);
                    this.isOver = false;
                    this.score = 0;
                    if(this.mode === 'rpg') this.hp = 100;
                    if(this.mode === 'ap') this.moves = 50;

                    document.getElementById('overlay').classList.remove('active');
                    this.updateUI();
                    this.spawnTile();
                    this.spawnTile();
                    this.render();
                }

                // AI å¾ªç¯
                aiLoop() {
                    if(this.isOver || this.mode !== 'auto_demo') return;
                    
                    const speedVal = parseInt(document.getElementById('ai-speed-slider').value);
                    const delay = 1100 - (speedVal * 100);

                    const bestMove = this.getBestMove();
                    
                    if(bestMove !== -1) {
                        const arrow = document.getElementById('ai-arrow');
                        arrow.style.display = 'block';
                        const arrows = ['â¬…ï¸', 'â¬†ï¸', 'â¡ï¸', 'â¬‡ï¸']; // 0,1,2,3
                        arrow.innerText = arrows[bestMove];
                        
                        setTimeout(() => {
                            if(this.mode === 'auto_demo') {
                                this.move(bestMove);
                                arrow.style.display = 'none';
                                this.aiTimer = setTimeout(() => this.aiLoop(), delay);
                            }
                        }, delay / 2); 
                    }
                }

               // --- å¤§å¸ˆçº§ AI æ ¸å¿ƒç®—æ³• (Exponential Expectimax) ---

                // 1. è·å–æœ€ä½³ç§»åŠ¨æ–¹å‘ (å…¥å£)
                getBestMove() {
                    let simpleGrid = this.grid.map(c => c ? c.val : 0);
                    
                    // åŠ¨æ€æ·±åº¦æ§åˆ¶ï¼š
                    // ç©ºä½è¶Šå°‘ï¼Œå±€é¢è¶Šå±é™©ï¼Œæ€è€ƒå¿…é¡»è¶Šæ·±ã€‚
                    // ç”µè„‘ç«¯ JS å¯ä»¥è·‘ Depth 4-5ï¼Œæ‰‹æœºç«¯ Depth 3-4 æ˜¯æé™ã€‚
                    let empties = simpleGrid.filter(x => x === 0).length;
                    
                    // ç­–ç•¥ï¼šå¹³æ—¶3å±‚ï¼Œå±æœºæ—¶åˆ»(ç©ºä½<4)åŠ æ·±åˆ°4å±‚
                    let depth = empties < 4 ? 4 : 3; 

                    let bestScore = -Infinity;
                    let bestMove = -1;

                    for (let direction = 0; direction < 4; direction++) {
                        let result = this.aiSimulateMove(simpleGrid, direction);
                        if (result.moved) {
                            // ç¬¬ä¸€æ¬¡é€’å½’ï¼šè¿›å…¥ Chance èŠ‚ç‚¹ (ç³»ç»Ÿç”Ÿæˆæ–¹å—)
                            let score = this.expectimax(result.grid, depth, false);
                            if (score > bestScore) {
                                bestScore = score;
                                bestMove = direction;
                            }
                        }
                    }
                    return bestMove;
                }

                // 2. Expectimax é€’å½’æœç´¢
                // isPlayer = true (AIå›åˆ, å–æœ€å¤§å€¼); false (ç³»ç»Ÿå›åˆ, å–å¹³å‡å€¼)
                expectimax(grid, depth, isPlayer) {
                    if (depth === 0) return this.evaluateGridWeighted(grid);

                    if (isPlayer) {
                        // Max Node (AI)
                        let maxScore = -Infinity;
                        let anyMove = false;
                        for (let direction = 0; direction < 4; direction++) {
                            let res = this.aiSimulateMove(grid, direction);
                            if (res.moved) {
                                anyMove = true;
                                let score = this.expectimax(res.grid, depth - 1, false);
                                if (score > maxScore) maxScore = score;
                            }
                        }
                        // å¦‚æœæ— è·¯å¯èµ°ï¼Œç»™äºˆæå¤§çš„æƒ©ç½šï¼Œé˜²æ­¢ AI èµ°è¿›æ­»èƒ¡åŒ
                        return anyMove ? maxScore : -1e9; 
                    } else {
                        // Chance Node (System)
                        let emptyIndices = [];
                        for(let i=0; i<16; i++) if(grid[i] === 0) emptyIndices.push(i);

                        if(emptyIndices.length === 0) return this.expectimax(grid, depth - 1, true);

                        // æ€§èƒ½ä¼˜åŒ–ï¼šåªè®¡ç®—å¯èƒ½æ€§æœ€å¤§çš„ç©ºä½ï¼Œé˜²æ­¢æµè§ˆå™¨å¡æ­»
                        // åœ¨ç©ºä½å¾ˆå¤šæ—¶ï¼Œéšæœºå– 3-4 ä¸ªæ ·æœ¬å³å¯ä»£è¡¨å¤§å±€
                        let candidates = emptyIndices;
                        if (candidates.length > 3) {
                            // ç®€å•çš„éšæœºé‡‡æ ·ä¼˜åŒ–æ€§èƒ½
                            candidates = candidates.sort(() => 0.5 - Math.random()).slice(0, 3);
                        }

                        let totalScore = 0;
                        for (let idx of candidates) {
                            // æƒ…å†µ A: ç”Ÿæˆ 2 (90% æ¦‚ç‡)
                            let grid2 = [...grid]; grid2[idx] = 2;
                            let score2 = this.expectimax(grid2, depth - 1, true);
                            totalScore += score2 * 0.9;

                            // æƒ…å†µ B: ç”Ÿæˆ 4 (10% æ¦‚ç‡) 
                            // *é‡è¦*: AI å¿…é¡»æ„è¯†åˆ°ç”Ÿæˆ 4 å¯èƒ½ä¼šå¡æ­»è‡ªå·±
                            let grid4 = [...grid]; grid4[idx] = 4;
                            let score4 = this.expectimax(grid4, depth - 1, true);
                            totalScore += score4 * 0.1;
                        }
                        return totalScore / candidates.length;
                    }
                }

                // 3. è¯„ä¼°å‡½æ•° (æŒ‡æ•°çº§è›‡å½¢æƒé‡)
                evaluateGridWeighted(grid) {
                    // æŒ‡æ•°æƒé‡çŸ©é˜µï¼šå¼ºè¿«æœ€å¤§çš„æ•°å‘†åœ¨å·¦ä¸‹è§’(15)ï¼Œç„¶åå‘ˆè›‡å½¢å‘ä¸Šç›˜æ—‹
                    // ä½¿ç”¨æŒ‡æ•° (4çš„æ¬¡æ–¹) ç¡®ä¿ 1024 çš„æƒé‡è¿œå¤§äº 512+256+... çš„æ€»å’Œ
                    // è¿™æ · AI ç»ä¸ä¼šä¸ºäº†è´ªåƒä¸€ä¸ªå°å…µè€Œç‰ºç‰²å¤§å°†çš„ä½ç½®
                    const weights = [
                         2,    5,   15,   30,  // Row 0 (é¡¶å±‚)
                        250, 180,  120,   60,  // Row 1
                        400, 700, 1200, 1800,  // Row 2
                       25000, 12000, 6000, 3000   // Row 3 (åº•å±‚ï¼Œå·¦ä¸‹è§’æœ€å¤§)
                    ];

                    let score = 0;
                    let maxVal = 0;
                    let maxIdx = -1;

                    for (let i = 0; i < 16; i++) {
                        let val = grid[i];
                        if (val > 0) {
                            // æ ¸å¿ƒå…¬å¼ï¼šæ•°å€¼ * æƒé‡
                            score += val * weights[i];
                            if (val > maxVal) {
                                maxVal = val;
                                maxIdx = i;
                            }
                        }
                    }

                    // æƒ©ç½šæœºåˆ¶ 1: æœ€å¤§çš„æ•°å¿…é¡»åœ¨å·¦ä¸‹è§’ (Index 12)
                    // å¦‚æœä¸åœ¨ï¼Œç»™äºˆæƒ©ç½šï¼Œè¿«ä½¿ AI æŠŠå®ƒç§»å›å»
                    if (maxIdx !== 12) {
                        score -= maxVal * 5000; 
                    }

                    // æƒ©ç½šæœºåˆ¶ 2: å¹³æ»‘æ€§ (ç›¸é‚»æ ¼å­æ•°å€¼å·®è¶Šå°è¶Šå¥½)
                    // è¿™èƒ½é˜²æ­¢å‡ºç° [1024, 2, 512, 4] è¿™ç§æ— æ³•åˆå¹¶çš„é”¯é½¿å½¢çŠ¶
                    let smoothnessPenalty = 0;
                    for (let r = 0; r < 4; r++) {
                        for (let c = 0; c < 4; c++) {
                            let idx = r * 4 + c;
                            if (grid[idx] === 0) continue;
                            
                            // å‘å³æ¯”å¯¹
                            if (c < 3) {
                                let rightIdx = idx + 1;
                                if (grid[rightIdx] !== 0) {
                                    smoothnessPenalty += Math.abs(grid[idx] - grid[rightIdx]);
                                }
                            }
                            // å‘ä¸‹æ¯”å¯¹
                            if (r < 3) {
                                let downIdx = idx + 4;
                                if (grid[downIdx] !== 0) {
                                    smoothnessPenalty += Math.abs(grid[idx] - grid[downIdx]);
                                }
                            }
                        }
                    }
                    
                    return score - smoothnessPenalty;
                }

                // 4. æ¨¡æ‹Ÿç§»åŠ¨ (ä½è¿ç®—ä¼˜åŒ–ç‰ˆé€»è¾‘)
                aiSimulateMove(grid, dir) {
                    let newGrid = [...grid];
                    let moved = false;
                    let size = 4; // AI ä»…ä¼˜åŒ– 4x4
                    const getIdx = (r, c) => r * size + c;

                    for (let i = 0; i < size; i++) {
                        let line = [];
                        for (let j = 0; j < size; j++) {
                            let idx = (dir === 0) ? getIdx(i, j) :
                                      (dir === 2) ? getIdx(i, size - 1 - j) :
                                      (dir === 1) ? getIdx(j, i) :
                                      getIdx(size - 1 - j, i);
                            line.push(newGrid[idx]);
                        }

                        let filtered = line.filter(x => x !== 0);
                        for (let k = 0; k < filtered.length - 1; k++) {
                            if (filtered[k] === filtered[k + 1]) {
                                filtered[k] *= 2;
                                filtered.splice(k + 1, 1);
                                moved = true;
                            }
                        }
                        while (filtered.length < size) filtered.push(0);

                        for (let j = 0; j < size; j++) {
                            let targetIdx = (dir === 0) ? getIdx(i, j) :
                                            (dir === 2) ? getIdx(i, size - 1 - j) :
                                            (dir === 1) ? getIdx(j, i) :
                                            getIdx(size - 1 - j, i);
                            if (newGrid[targetIdx] !== filtered[j]) moved = true;
                            newGrid[targetIdx] = filtered[j];
                        }
                    }
                    return { moved, grid: newGrid };
                }

                spawnTile(forceType = null) {
                    let empties = this.grid.map((c, i) => c === null ? i : null).filter(i => i !== null);
                    if (empties.length === 0) return;
                    if (this.mode === 'gravity') empties = empties.filter(idx => idx < this.size);
                    if (empties.length === 0) return;

                    const idx = empties[Math.floor(Math.random() * empties.length)];
                    let val = Math.random() < 0.9 ? 2 : 4;
                    let type = 'normal';

                    if (this.mode === 'rpg') {
                        let r = Math.random();
                        if (r < 0.2) { type = 'enemy'; val = Math.pow(2, Math.floor(Math.random()*3)+1); }
                        else if (r < 0.25) { type = 'potion'; val = 0; }
                    }
                    this.grid[idx] = { val, type, id: Math.random() };
                }

                move(dir) {
                    if (this.isOver) return;
                    if (this.mode === 'gravity' && dir === 1) return;

                    let moved = false;
                    let scoreGain = 0;
                    const getIdx = (r, c) => r * this.size + c;
                    
                    for (let i = 0; i < this.size; i++) {
                        let lineObj = [];
                        for (let j = 0; j < this.size; j++) {
                            let idx;
                            if (dir === 0) idx = getIdx(i, j);
                            else if (dir === 2) idx = getIdx(i, this.size - 1 - j);
                            else if (dir === 1) idx = getIdx(j, i);
                            else idx = getIdx(this.size - 1 - j, i);
                            lineObj.push(this.grid[idx]);
                        }

                        let processed = [];
                        let buffer = null;
                        let cells = lineObj.filter(c => c !== null);

                        for (let k = 0; k < cells.length; k++) {
                            let curr = cells[k];
                            if (!buffer) { buffer = curr; } 
                            else {
                                let res = this.interact(buffer, curr);
                                if (res.action === 'merge') {
                                    processed.push({ val: res.val, type: res.type || 'normal' });
                                    scoreGain += res.score;
                                    buffer = null;
                                    if(window.audioManager && this.mode !== 'auto_demo') window.audioManager.playSFX();
                                } else if (res.action === 'block') {
                                    processed.push(buffer);
                                    buffer = curr;
                                } else if (res.action === 'destroy') {
                                    if (res.val !== null) processed.push({ val: res.val, type: 'normal' });
                                    buffer = null;
                                    if(window.audioManager && this.mode !== 'auto_demo') window.audioManager.playSFX();
                                }
                            }
                        }
                        if (buffer) processed.push(buffer);
                        while (processed.length < this.size) processed.push(null);

                        for (let j = 0; j < this.size; j++) {
                            let targetIdx;
                            if (dir === 0) targetIdx = getIdx(i, j);
                            else if (dir === 2) targetIdx = getIdx(i, this.size - 1 - j);
                            else if (dir === 1) targetIdx = getIdx(j, i);
                            else targetIdx = getIdx(this.size - 1 - j, i);

                            let oldVal = this.grid[targetIdx];
                            let newVal = processed[j];
                            if (oldVal !== newVal) {
                                if (oldVal !== null || newVal !== null) {
                                     if (!oldVal || !newVal || oldVal.val !== newVal.val || oldVal.type !== newVal.type) moved = true;
                                }
                            }
                            this.grid[targetIdx] = newVal;
                        }
                    }

                    if (moved) {
                        this.score += scoreGain;

                        if (this.mode === 'ap') {
                            this.moves--;
                            if (scoreGain > 0) this.moves += Math.floor(scoreGain /8); 
                            if (this.moves <= 0) { this.endGame("æ­¥æ•°è€—å°½ï¼æŒ‘æˆ˜å¤±è´¥ï¼"); return; }
                        }

                        let maxVal = 0;
                        this.grid.forEach(cell => { if (cell && cell.val > maxVal) maxVal = cell.val; });
                        let target = 2048;
                        if (maxVal >= target && !this.isOver) {
                            // æ— å°½æ¨¡å¼å’ŒAIæ¼”ç¤ºæ¨¡å¼ä¸ç»“æŸæ¸¸æˆ
                            if(this.mode === 'auto_demo' || this.mode === 'endless') {
                                // ç»§ç»­æ¸¸æˆ
                            } else {
                                let winMsg = "æ­å–œï¼è¾¾æˆ 2048ï¼";
                                if(this.mode === 'city') winMsg = "æ­å–œé“å‹è¯æ— ä¸Šé“æœï¼Œä¿®æˆçœŸä»™ï¼";
				if(this.mode === 'rpg') winMsg = "ä¼ è¯´é­”ç‹å·²è¢«å‡»è´¥ï¼ä¸–ç•Œå’Œå¹³ï¼"

                    		    localStorage.setItem('ai_unlocked', 'true'); // è®°å½•è§£é”çŠ¶æ€

                                this.endGame(winMsg);
                                return;
                            }
                        }

                        this.spawnTile();
                        this.render();

                        if (this.isGridFull() && !this.canMove()) {
                            if(this.mode === 'auto_demo') {
                                setTimeout(() => this.restart(), 2000); 
                            } else {
                                this.endGame("æ— æ³•ç§»åŠ¨äº†ï¼æ¸¸æˆç»“æŸï¼");
                            }
                        }
                    }
                }

                interact(a, b) {
                    if (b.type === 'potion') { this.heal(20); return { action: 'block', val: a.val }; }
                    if (a.type === 'potion') { this.heal(20); return { action: 'merge', val: b.val, type: b.type, score: 0 }; }
                    if (b.type === 'potion') { this.heal(20); return { action: 'merge', val: b.val, type: b.type, score: 0 }; }

                    if (this.mode === 'rpg') {
                        let hero = null, monster = null;
                        if (a.type !== 'enemy' && b.type === 'enemy') { hero = a; monster = b; }
                        else if (a.type === 'enemy' && b.type !== 'enemy') { hero = b; monster = a; }

                        if (hero && monster) {
                            if (hero.val >= monster.val) return { action: 'merge', val: hero.val * 2, type: 'normal', score: monster.val };
                            else { this.takeDamage(15); return { action: 'block' }; }
                        }
                        if (a.type === 'enemy' && b.type === 'enemy' && a.val === b.val) return { action: 'merge', val: a.val * 2, type: 'enemy', score: 0 };
                    }

                    if (a.val === b.val && a.type === b.type) return { action: 'merge', val: a.val * 2, type: a.type, score: a.val * 2 };
                    return { action: 'block' };
                }

                takeDamage(amount) {
                    this.hp = Math.max(0, this.hp - amount);
                    const board = document.getElementById('game-board');
                    board.style.animation = 'pulse 0.2s';
                    setTimeout(() => board.style.animation = '', 200);
                    if (this.hp <= 0) this.endGame("è‹±é›„ç‰ºç‰²äº†ï¼");
                    this.updateUI();
                }

                heal(amount) { this.hp = Math.min(this.maxHp, this.hp + amount); this.updateUI(); }
                isGridFull() { return !this.grid.includes(null); }
                
                canMove() {
                    if (this.isGridFull() === false) return true;
                    for (let i = 0; i < this.size; i++) {
                        for (let j = 0; j < this.size; j++) {
                            let idx = i * this.size + j;
                            let val = this.grid[idx].val;
                            if (j < this.size - 1) { if (val === this.grid[idx + 1].val) return true; }
                            if (i < this.size - 1) { if (val === this.grid[idx + this.size].val) return true; }
                        }
                    }
                    return false;
                }

                endGame(msg) {
                    this.isOver = true;
                    if(this.aiTimer) clearTimeout(this.aiTimer);
                    document.getElementById('overlay-msg').innerText = msg;
                    document.getElementById('overlay-desc').innerText = `æœ€ç»ˆå¾—åˆ†: ${this.score}`;
                    document.getElementById('overlay').classList.add('active');
                }

                updateUI() {
                    document.getElementById('score').innerText = this.score;
                    document.getElementById('moves').innerText = this.moves;
                    if (this.mode === 'rpg') {
                        const pct = (this.hp / this.maxHp) * 100;
                        document.getElementById('hp-fill').style.width = pct + "%";
                        document.getElementById('hp-text').innerText = `HP: ${this.hp}/${this.maxHp}`;
                    }
                }

                render() {
                    const board = document.getElementById('game-board');
                    const overlay = document.getElementById('overlay');
                    const arrow = document.getElementById('ai-arrow');
                    board.innerHTML = '';
                    board.appendChild(overlay);
                    board.appendChild(arrow); 

                    this.grid.forEach(cell => {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        if (cell) {
                            const inner = document.createElement('div');
                            inner.className = `tile-inner val-${cell.val > 2048 ? 2048 : cell.val} type-${cell.type}`;
                            if (cell.type === 'potion') { inner.innerHTML = 'ğŸ’Š'; } 
                            else if (cell.type === 'enemy') {
                                inner.innerHTML = 'ğŸ’€<br>' + cell.val;
                                inner.style.flexDirection = 'column';
                                inner.style.fontSize = 'calc(var(--tile-font-size) * 0.6)';
                            } else if (this.mode === 'city' && cell.type === 'normal') {
                                inner.innerText = CITY_NAMES[cell.val] || cell.val;
                                inner.style.fontSize = this.size > 5 ? '12px' : '16px';
                            } else {
                                inner.innerText = cell.val;
                            }
                            tile.appendChild(inner);
                        }
                        board.appendChild(tile);
                    });
                    this.updateUI();
                }
            }

            // --- 7. å…¨å±€åˆå§‹åŒ– ---
            window.audioManager = new AudioManager();
            window.gridGame = new GridGame();
            window.physicsGame = new PhysicsGame();
            // window.snakeGame = new SnakeGame(); // å·²ç§»é™¤

            window.game = {
                start: (mode) => {
                    document.getElementById('start-screen').classList.add('hidden');
                    document.getElementById('game-screen').classList.remove('hidden');
                    if (mode === 'shoot') window.physicsGame.start();
                    else window.gridGame.start(mode);
                },
                endlessSetup: () => {
                     let size = prompt("è¯·è¾“å…¥ç½‘æ ¼å¤§å° (4-9)", "4");
                     if(size === null) return;
                     size = parseInt(size);
                     if(isNaN(size) || size < 4) size = 4;
                     if(size > 9) size = 9;
                     
                     document.getElementById('start-screen').classList.add('hidden');
                     document.getElementById('game-screen').classList.remove('hidden');
                     window.gridGame.start('endless', size);
                },
                showMenu: () => {
                    document.getElementById('start-screen').classList.remove('hidden');
                    document.getElementById('game-screen').classList.add('hidden');
                    if (window.physicsGame.animationId) cancelAnimationFrame(window.physicsGame.animationId);
                    if (window.gridGame.aiTimer) clearTimeout(window.gridGame.aiTimer);
			window.checkAIUnlock(); 
                },
                restartGrid: () => window.gridGame.restart(),
                restartPhysics: () => window.physicsGame.restart()
            };

            // é”®ç›˜äº‹ä»¶
            document.addEventListener('keydown', e => {
                if (document.getElementById('game-screen').classList.contains('hidden')) return;
                if (document.getElementById('physics-stage').style.display === 'block') return;

                if (window.gridGame.mode === 'auto_demo') return;

                if (e.key === 'ArrowLeft') window.gridGame.move(0);
                else if (e.key === 'ArrowUp') window.gridGame.move(1);
                else if (e.key === 'ArrowRight') window.gridGame.move(2);
                else if (e.key === 'ArrowDown') window.gridGame.move(3);
            });

            // è§¦æ‘¸äº‹ä»¶
            let tx = 0, ty = 0;
            const touchArea = document.getElementById('game-screen');
            touchArea.addEventListener('touchstart', e => { 
                if (e.target.tagName === 'BUTTON' || e.target.closest('button') || e.target.tagName === 'INPUT') return;
                tx = e.touches[0].clientX; 
                ty = e.touches[0].clientY; 
                if(document.getElementById('physics-stage').style.display !== 'block' && e.cancelable) e.preventDefault(); 
            }, {passive: false});

            touchArea.addEventListener('touchmove', e => { 
               if(document.getElementById('physics-stage').style.display !== 'block') e.preventDefault(); 
            }, {passive: false});

            touchArea.addEventListener('touchend', e => {
                if(document.getElementById('physics-stage').style.display === 'block') return;
                if(e.target.tagName === 'INPUT') return; 

                let dx = e.changedTouches[0].clientX - tx;
                let dy = e.changedTouches[0].clientY - ty;
                
                let moveDir = -1;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (Math.abs(dx) > 30) moveDir = dx > 0 ? 2 : 0;
                } else {
                    if (Math.abs(dy) > 30) moveDir = dy > 0 ? 3 : 1;
                }

                if(moveDir !== -1) {
                     if (window.gridGame.mode !== 'auto_demo') {
                         window.gridGame.move(moveDir);
                     }
                }
            });
        });
    </script>
</body>
</html>