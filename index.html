<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 ç©æ³•å®éªŒå®¤</title>
<meta name="color-scheme" content="light only">
    <style>
        /* --- 1. åŸºç¡€è§†è§‰é£æ ¼ --- */
        :root {
            --bg-color: #faf8ef;
            --text-color: #776e65;
            --board-bg: #bbada0;
            --cell-empty: #cdc1b4;
            --btn-bg: #8f7a66;
            --btn-text: #f9f6f2;
	    color-scheme: light;
            
            /* åŠ¨æ€å˜é‡ */
            --grid-size: 4; 
            --tile-font-size: 30px; 

            /* é¢œè‰²é…ç½® */
            --hp-fill: #e74c3c;
            --enemy-color: #c0392b;
            --potion-color: #2ecc71;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            overflow-x: hidden;
        }

        /* --- é¡¶éƒ¨å¯¼èˆªæ  --- */
        .top-bar {
            width: 100%; 
            max-width: 600px;
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            padding: 10px 20px; 
            background: rgba(255,255,255,0.8);
            backdrop-filter: blur(5px);
            z-index: 100;
            height: 60px;
            position: sticky;
            top: 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .icon-btn {
            font-size: 16px; cursor: pointer; padding: 8px 16px;
            background: #fff; border: 2px solid #eee4da; border-radius: 20px; 
            color: var(--text-color); display: flex; align-items: center; gap: 6px;
            font-weight: bold; transition: background 0.1s;
        }
        .icon-btn:active { background: #e0e0e0; transform: scale(0.95); }
        .icon-btn span { pointer-events: none; }

        /* --- è®¾ç½®å¼¹çª— --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex; justify-content: center; align-items: center;
            z-index: 9999;
            opacity: 0; pointer-events: none; transition: opacity 0.2s;
        }
        .modal.active { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: #fff; padding: 25px; border-radius: 12px; width: 85%; max-width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
        }
        .setting-row { margin-bottom: 20px; text-align: left; }
        .setting-row label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
        .setting-row select { width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #ccc; font-size: 16px; background: #fff; }
        .close-btn { width: 100%; background: var(--btn-bg); color: white; border: none; padding: 12px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; }

        /* --- é€šç”¨å®¹å™¨ --- */
        .screen { 
            width: 100%; 
            flex: 1;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 10px;
            padding-bottom: 50px;
        }
        .hidden { display: none !important; }

        /* --- æ¨¡å¼é€‰æ‹©å¡ç‰‡ --- */
        .mode-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 100%;
            max-width: 500px;
            margin-bottom: 20px;
        }

        .mode-card {
            background: #fff;
            border: 2px solid #eee4da;
            border-radius: 12px;
            padding: 20px 10px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: transform 0.1s, background-color 0.1s;
        }
        .mode-card:active { transform: scale(0.96); background-color: #f0f0f0; border-color: var(--btn-bg); }
        .mode-card > * { pointer-events: none; }
        .mode-card h3 { margin: 8px 0; font-size: 18px; color: #555; }
        .mode-card p { margin: 0; font-size: 13px; color: #999; }
        .mode-icon { font-size: 32px; margin-bottom: 5px; }

        /* --- æ¸¸æˆå¤´éƒ¨ --- */
        .header-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .stat-group { display: flex; gap: 10px; }
        .stat-box {
            background: #bbada0;
            padding: 5px 15px;
            border-radius: 6px;
            color: white;
            text-align: center;
            min-width: 70px;
        }
        .stat-title { font-size: 12px; text-transform: uppercase; opacity: 0.9; }
        .stat-value { font-size: 20px; font-weight: bold; }

        /* RPGè¡€æ¡ */
        .hp-container {
            width: 100%; max-width: 500px;
            height: 12px; background: #ddd; border-radius: 6px; margin-bottom: 5px; overflow: hidden; display: none;
        }
        .hp-fill { height: 100%; background: var(--hp-fill); width: 100%; transition: width 0.3s ease; }

        /* --- æ ¸å¿ƒï¼šæ¸¸æˆæ£‹ç›˜ --- */
        #game-board-container {
            width: min(92vw, 500px);
            aspect-ratio: 1 / 1;
            position: relative;
            margin-top: 5px;
            touch-action: none;
        }

        #game-board {
            background-color: var(--board-bg);
            border-radius: 8px;
            padding: 10px;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(var(--grid-size, 4), 1fr);
            grid-template-rows: repeat(var(--grid-size, 4), 1fr);
            gap: 8px;
            box-sizing: border-box;
        }

        .tile {
            background-color: var(--cell-empty);
            border-radius: 6px;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: var(--tile-font-size);
            position: relative;
            transition: transform 0.1s;
        }

        .tile-inner {
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            border-radius: 4px;
            animation: appear 0.2s ease-in;
            color: #f9f6f2;
        }
        
        /* é¢œè‰²è¡¨ */
       .val-2 { background: #eee4da; color: #776e65; }
	.val-4 { background: #ffe082; color: #776e65; }
        .val-8 { background: #ff9800; color: #fff; }
        .val-16 { background: #f59563; }
        .val-32 { background: #f67c5f; }
        .val-64 { background: #f65e3b; }
        .val-128 { background: #edcf72; font-size: calc(var(--tile-font-size) * 0.8); }
        .val-256 { background: #edcc61; font-size: calc(var(--tile-font-size) * 0.8); }
        .val-512 { background: #edc850; font-size: calc(var(--tile-font-size) * 0.8); }
        .val-1024 { background: #edc53f; font-size: calc(var(--tile-font-size) * 0.6); }

        /* ç‰¹æ®Šæ–¹å— */
        .type-enemy { background: var(--enemy-color) !important; border: 2px solid #a93226; box-sizing: border-box; }
        .type-potion { background: var(--potion-color) !important; font-size: calc(var(--tile-font-size) * 1.2); }

        /* --- 5. ç‰©ç†å°„å‡»æ¨¡å¼é€‚é… --- */
        #physics-stage {
            width: min(92vw, 400px);
            height: min(138vw,600px);
            background: #2c3e50;
            position: relative;
            border-radius: 10px; overflow: hidden;
            border: 4px solid #34495e;
            touch-action: none;
            cursor: crosshair;
            margin: 0 auto 20px auto;
        }
        .phy-block {
            position: absolute; width: 60px; height: 60px;
            border-radius: 10px;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 24px; color: white;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 10;
        }
        .aim-line {
            position: absolute; width: 0; height: 0;
            border-left: 2px dashed rgba(255,255,255,0.5);
            top: 0; pointer-events: none; display: none; z-index: 5; transform-origin: top center;
        }

        /* åŠ¨ç”»ä¸é®ç½© */
        @keyframes appear { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        
        .overlay {
            position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: rgba(250, 248, 239, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 50;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        
        button {
            background: var(--btn-bg); color: #fff; border: none; padding: 12px 24px; 
            border-radius: 6px; font-size: 16px; cursor: pointer; margin: 8px;
            font-weight: bold;
        }
        button:active { background: #736252; transform: scale(0.95); }

	/* æ–°å¢è­¦æˆ’çº¿æ ·å¼ */
	#limit-line {
    position: absolute;
    width: 100%;
    height: 2px;
    border-top: 2px dashed #e74c3c; /* çº¢è‰²è™šçº¿ */
    left: 0;
    z-index: 5;
    pointer-events: none; /* é˜²æ­¢æŒ¡ä½ç‚¹å‡» */
    /* topå€¼ä¼šåœ¨JSé‡ŒåŠ¨æ€è®¡ç®— */
	}

	/* å¯ä»¥åœ¨è¿™é‡Œç»™ shooter-area åŠ ä¸€ç‚¹èƒŒæ™¯è‰²æ–¹ä¾¿åŒºåˆ†ï¼ˆå¯é€‰ï¼‰ */
	.shooter-area {
    background: rgba(0, 0, 0, 0.1); 
	}


    </style>
</head>
<body>

    <!-- é¡¶éƒ¨å¯¼èˆª -->
    <div class="top-bar">
        <h2 style="margin:0; font-size: 20px; color: #776e65; font-weight: bold;">2048ç©æ³•å®éªŒå®¤</h2>
        <button class="icon-btn" onclick="window.ui.toggleSettings()">
            <span style="font-size: 18px;">âš™ï¸</span>
            <span>è®¾ç½®</span>
        </button>
    </div>

    <!-- è®¾ç½®å¼¹çª— -->
    <div class="modal" id="settings-modal">
        <div class="modal-content">
            <h3 style="margin-top:0; text-align: center; color: #776e65;">æ¸¸æˆè®¾ç½®</h3>
            
            <div class="setting-row">
                <label>èƒŒæ™¯éŸ³ä¹ (BGM)</label>
                <select id="bgm-select" onchange="window.audioManager.changeBGM(this.value)">
                </select>
            </div>
            
            <div class="setting-row">
                <label>éŸ³æ•ˆ (SFX)</label>
                <select id="sfx-select" onchange="window.audioManager.changeSFX(this.value)">
                </select>
            </div>
            
            <div class="setting-row" style="font-size: 12px; color: #999; line-height: 1.5;">
                * æç¤º: éœ€åœ¨æ ¹ç›®å½•åˆ›å»º bgm/ å’Œ sfx/ æ–‡ä»¶å¤¹æ”¾å…¥éŸ³é¢‘æ–‡ä»¶ã€‚è‹¥æ— æ–‡ä»¶åˆ™æ— å£°ï¼Œä½†ä¸å½±å“æ¸¸æˆã€‚
            </div>

            <button class="close-btn" onclick="window.ui.toggleSettings()">å®Œæˆ</button>
        </div>
    </div>

    <!-- æ¨¡å¼é€‰æ‹©ç•Œé¢ -->
    <div id="start-screen" class="screen">
        <h1 style="font-size: 28px; color: #776e65; margin-bottom: 5px;">é€‰æ‹©æ¸¸æˆæ¨¡å¼</h1>
        <p style="color: #999; margin-bottom: 25px; font-size: 14px;">ç‚¹å‡»å¡ç‰‡å¼€å§‹æŒ‘æˆ˜</p>
        
        <div class="mode-grid">
            <div class="mode-card" onclick="window.game.start('classic')">
                <span class="mode-icon">ğŸ”¢</span>
                <h3>ç»å…¸æ¨¡å¼</h3>
                <p>4x4 åŸæ±åŸå‘³</p>
            </div>
            <div class="mode-card" onclick="window.game.start('rpg')">
                <span class="mode-icon">âš”ï¸</span>
                <h3>RPG2048</h3>
                <p>4x4 æ‰“æ€ªå—‘è¯</p>
            </div>
            <div class="mode-card" onclick="window.game.start('gravity')">
                <span class="mode-icon">ğŸ</span>
                <h3>ä¿„ç½—æ–¯æ–¹å—2048</h3>
                <p>4x4 åªèƒ½ä¸‹è½ã€å·¦å³ç§»åŠ¨</p>
            </div>
            <div class="mode-card" onclick="window.game.start('ap')">
                <span class="mode-icon">ğŸ‘£</span>
                <h3>æ­¥æ­¥ä¸ºè¥2048</h3>
                <p>4x4 æ­¥æ•°æœ‰é™ï¼Œä¸‰æ€åè¡Œ</p>
            </div>
            <div class="mode-card" onclick="window.game.start('city')">
                <span class="mode-icon">âš¡</span>
                <h3>ä¿®ä»™2048</h3>
                <p>4x4å‡¡äººä¿®ä»™ï¼Œé€†å¤©æ”¹å‘½</p>
            </div>
            <div class="mode-card" onclick="window.game.start('shoot')">
                <span class="mode-icon">ğŸ¹</span>
                <h3>æ³¡æ³¡é¾™2048</h3>
                <p>å°„å‡»ç¢°æ’ç©æ³•</p>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆä¸»ç•Œé¢ -->
    <div id="game-screen" class="screen hidden">
        <div class="header-bar">
            <button onclick="window.game.showMenu()" style="font-size:14px; padding:8px 15px;">â¬… èœå•</button>
            <div class="stat-group">
                <div class="stat-box">
                    <div class="stat-title">å¾—åˆ†</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <!-- ç‰¹æ®ŠçŠ¶æ€æ ï¼šæ­¥æ•° -->
                <div class="stat-box" id="moves-box" style="display:none;">
                    <div class="stat-title">æ­¥æ•°</div>
                    <div class="stat-value" id="moves">50</div>
                </div>
            </div>
        </div>

        <!-- RPGè¡€æ¡ -->
        <div class="hp-container" id="hp-bar">
            <div class="hp-fill" id="hp-fill" style="width: 100%;"></div>
        </div>
        <div id="hp-text" style="font-size: 13px; color: #e74c3c; margin-bottom: 8px; font-weight: bold; display:none;">HP: 100/100</div>

        <!-- 1. ç½‘æ ¼æ¸¸æˆåŒºåŸŸ (RPG/Classic/City...) -->
        <div id="game-board-container">
            <div id="game-board">
                <!-- æ¸¸æˆåŒºåŸŸ -->
                <div class="overlay" id="overlay">
                    <h2 id="overlay-msg" style="font-size: 32px; color: #776e65; margin: 10px;">Game Over</h2>
                    <div id="overlay-desc" style="margin-bottom: 20px; color: #999;"></div>
                    <button onclick="window.game.restartGrid()">å†è¯•ä¸€æ¬¡</button>
                    <button onclick="window.game.showMenu()">ä¸»èœå•</button>
                </div>
            </div>
            <p id="game-tip" style="margin-top: 15px; font-size: 14px; color: #aaa; text-align: center; max-width: 90%;"></p>
        </div>

        <!-- 2. ç‰©ç†å°„å‡»æ¸¸æˆå®¹å™¨ -->
        <div id="physics-stage" style="display:none;">
	    <div id="limit-line"></div> 
            <div class="aim-line" id="aim-line"></div>
            <div class="shooter-area"></div>
            <!-- æ–¹å—åŠ¨æ€ç”Ÿæˆ -->
            <div class="overlay" id="phy-overlay">
                <h2>å †æ»¡å•¦!</h2>
                <div id="phy-overlay-desc" style="margin-bottom: 20px; color: #999;"></div>
                <button onclick="window.game.restartPhysics()">é‡ç©</button>
                <button onclick="window.game.showMenu()">è¿”å›èœå•</button>
            </div>
        </div>
    </div>

    <script>
        // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆï¼Œé˜²æ­¢ç‚¹å‡»å¤±æ•ˆ
        window.addEventListener('load', function() {

            // --- 1. å…¨å±€é…ç½® ---
            const AUDIO_CONFIG = {
                bgmList: [
                    { name: "é»˜è®¤éŸ³ä¹", file: "default.mp3" },
                    { name: "æ³¡æ³¡é¾™", file: "Bubbly.mp3" },
		    { name: "ä¿„ç½—æ–¯æ–¹å—", file: "Tetris.mp3" },
		    { name: "æ­¥æ­¥ä¸ºè¥", file: "step" },
		    { name: "å°¤å…‹é‡Œé‡Œ", file: "Ukulele.mp3" },
                    { name: "å‡¡äººä¿®ä»™",   file: "xian.mp3" }
                ],
                sfxList: [
                    { name: "é»˜è®¤æ°”æ³¡", file: "pop.mp3" },
                    { name: "é‡‘å¸",   file: "coin.mp3" },
	 	    { name: "æ¿€å…‰",   file: "laser.mp3" },
                    { name: "å†°å—",   file: "ice.mp3" }
                ]
            };

            const CONFIG = {
                classic: { size: 4, tip: "ç»å…¸ç©æ³•ï¼Œåˆæˆ2048è·èƒœã€‚" },
                rpg:     { size: 4, tip: "ğŸ’€æ˜¯æ€ªç‰©ï¼ŒğŸ’Šå›è¡€ã€‚è‹±é›„æ•°å€¼ >= æ€ªç‰©æ‰èƒ½å‡»æ€å‡çº§ï¼Œå¦åˆ™æ‰£è¡€ï¼" },
                gravity: { size: 4, tip: "é‡åŠ›å¼‚å¸¸ï¼åªèƒ½å‘å·¦ã€å³ã€ä¸‹æ»‘åŠ¨ã€‚æ–¹å—åªä»é¡¶éƒ¨ç”Ÿæˆã€‚" },
                ap:      { size: 4, tip: "æ·±æ€ç†Ÿè™‘ï¼æ¯èµ°ä¸€æ­¥æ¶ˆè€—1ç‚¹æ­¥æ•°ï¼Œåˆæˆ8å›å¤5ç‚¹æ­¥æ•°ã€‚" },
                city:    { size: 4, tip: " å‡¡äºº->ç‚¼æ°” ->ç­‘åŸº ->é‡‘ä¸¹ ->å…ƒå©´ -> åŒ–ç¥ ->ç‚¼è™š ->åˆä½“ ->å¤§ä¹˜  ->æ¸¡åŠ« ->çœŸä»™ã€‚" },
                shoot:   { size: 0, tip: "æ‹–åŠ¨ç„å‡†ï¼Œæ¾æ‰‹å°„å‡»ï¼" }
            };

            const CITY_NAMES = { 
               2: "å‡¡äºº", 4: "ç‚¼æ°”", 8: "ç­‘åŸº", 16: "é‡‘ä¸¹", 32: "å…ƒå©´", 64: "åŒ–ç¥", 128: "ç‚¼è™š", 
		256: "åˆä½“", 512: "å¤§ä¹˜", 1024: "æ¸¡åŠ«", 2048: "çœŸä»™"
            };

            // --- 2. éŸ³é¢‘ç®¡ç†å™¨ ---
            class AudioManager {
                constructor() {
                    this.bgm = new Audio();
                    this.bgm.loop = true;
                    this.sfx = new Audio();
                    this.bgmPath = 'bgm/';
                    this.sfxPath = 'sfx/';
                    
                    this.initUI();
                    
                    if(AUDIO_CONFIG.bgmList.length > 0) this.changeBGM(AUDIO_CONFIG.bgmList[0].file);
                    if(AUDIO_CONFIG.sfxList.length > 0) this.changeSFX(AUDIO_CONFIG.sfxList[0].file);
                    
                    // å°è¯•æ’­æ”¾ (æµè§ˆå™¨å¯èƒ½é˜»æ­¢)
                    document.body.addEventListener('click', () => {
                        if (this.bgm.paused) this.bgm.play().catch(e=>{});
                    }, { once: true });
                }

                initUI() {
                    const bgmSelect = document.getElementById('bgm-select');
                    const sfxSelect = document.getElementById('sfx-select');
                    
                    if(bgmSelect) {
                        bgmSelect.innerHTML = "";
                        AUDIO_CONFIG.bgmList.forEach(item => {
                            const opt = document.createElement('option');
                            opt.value = item.file; opt.innerText = item.name;
                            bgmSelect.appendChild(opt);
                        });
                    }

                    if(sfxSelect) {
                        sfxSelect.innerHTML = "";
                        AUDIO_CONFIG.sfxList.forEach(item => {
                            const opt = document.createElement('option');
                            opt.value = item.file; opt.innerText = item.name;
                            sfxSelect.appendChild(opt);
                        });
                    }
                }

                changeBGM(filename) {
                    this.bgm.src = this.bgmPath + filename;
                    this.bgm.play().catch(e=>{});
                }

                changeSFX(filename) {
                    this.sfx.src = this.sfxPath + filename;
                }

                playSFX() {
                    try {
                        const sound = this.sfx.cloneNode();
                        sound.play().catch(e=>{});
                    } catch(e){}
                }
            }
            
            // --- 3. UI æ§åˆ¶ ---
            window.ui = {
                toggleSettings: () => {
                    const modal = document.getElementById('settings-modal');
                    if(modal) modal.classList.toggle('active');
                }
            };

            // --- 4. ç‰©ç†å°„å‡»æ¸¸æˆé€»è¾‘ ---
            class PhysicsGame {
                constructor() {
                    this.stage = document.getElementById('physics-stage');
                    this.width = 0; 
                    this.height = 0;
                    this.blocks = [];
                    this.currentBlock = null;
                    this.isAiming = false;
                    this.animationId = null;
                    this.score = 0;
                    this.blockSize = 60;
                    
                    this.stage.addEventListener('pointerdown', e => this.onDragStart(e));
                    this.stage.addEventListener('pointermove', e => this.onDragMove(e));
                    this.stage.addEventListener('pointerup', e => this.onDragEnd(e));
                    this.stage.addEventListener('pointerleave', e => this.onDragEnd(e));
                }

                start() {
                    this.stage.style.display = 'block';
                    document.getElementById('game-board-container').style.display = 'none';
                    document.getElementById('hp-bar').style.display = 'none';
                    document.getElementById('hp-text').style.display = 'none';
                    document.getElementById('moves-box').style.display = 'none';
                    document.getElementById('game-tip').innerText = CONFIG['shoot'].tip;

                    this.width = this.stage.clientWidth;
                    this.height = this.stage.clientHeight;

// â–¼â–¼â–¼ æ–°å¢/ä¿®æ”¹ä»£ç  â–¼â–¼â–¼
    // 1. è®¾å®šå‘å°„ç‚¹ Y åæ ‡ (è·ç¦»åº•éƒ¨ 70px)
    this.spawnY = this.height - 70; 
    
    // 2. è®¾å®šè­¦æˆ’çº¿ Y åæ ‡ (åœ¨å‘å°„ç‚¹ä¸Šæ–¹ 80px å¤„ï¼Œå³è·ç¦»åº•éƒ¨ 150px)
    // æ•°å€¼è¶Šå°ï¼Œçº¿è¶Šé ä¸Š
    this.limitY = this.spawnY - 80; 

    // 3. å°†çº¢çº¿ç”»åœ¨è®¡ç®—å‡ºçš„ä½ç½®
    const limitEl = document.getElementById('limit-line');
    if(limitEl) limitEl.style.top = this.limitY + "px";
    // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

                    this.restart();
                }

                restart() {
                    this.blocks = [];
                    this.score = 0;
                    this.updateScore(0);
                    document.getElementById('phy-overlay').classList.remove('active');
                    
                    const oldBlocks = document.querySelectorAll('.phy-block');
                    oldBlocks.forEach(b => b.remove());

                    if (this.animationId) cancelAnimationFrame(this.animationId);
                    this.spawnBlock();
                    this.loop();
                }
                
                updateScore(val) {
                    this.score = val;
                    document.getElementById('score').innerText = this.score;
                }

                spawnBlock() {
                    const val = Math.random() < 0.7 ? 2 : 4;
                    const el = document.createElement('div');
                    el.className = `phy-block val-${val}`;
                    el.innerText = val;
                    this.stage.appendChild(el);

                    this.currentBlock = {
                        el: el, val: val,
                        x: this.width / 2 - this.blockSize / 2,
                        y: this.spawnY, 
                        vx: 0, vy: 0, state: 'ready'
                    };
                    this.updateEl(this.currentBlock);
                }

                onDragStart(e) {
                    if (!this.currentBlock || this.currentBlock.state !== 'ready') return;
                    this.isAiming = true;
                    this.stage.setPointerCapture(e.pointerId);
                    this.onDragMove(e);
                }

                onDragMove(e) {
                    if (!this.isAiming || !this.currentBlock) return;
                    const rect = this.stage.getBoundingClientRect();
                    let x = e.clientX - rect.left - this.blockSize/2;
                    x = Math.max(0, Math.min(this.width - this.blockSize, x));
                    this.currentBlock.x = x;
                    this.updateEl(this.currentBlock);

                    const line = document.getElementById('aim-line');
                    line.style.display = 'block';
                    line.style.left = (x + this.blockSize/2) + 'px';
                    line.style.height = (this.currentBlock.y) + 'px';
                }

                onDragEnd(e) {
                    if (!this.isAiming) return;
                    this.isAiming = false;
                    document.getElementById('aim-line').style.display = 'none';
                    
                    if (this.currentBlock) {
                        this.currentBlock.state = 'moving';
                        this.currentBlock.vy = -18;
                        this.blocks.push(this.currentBlock);
                        this.currentBlock = null;
                        if(window.audioManager) window.audioManager.playSFX();
                        setTimeout(() => this.spawnBlock(), 600);
                    }
                }

                loop() {
                    this.updatePhysics();
                    this.animationId = requestAnimationFrame(() => this.loop());
                }

                updatePhysics() {
                    for (let i = 0; i < this.blocks.length; i++) {
                        let b = this.blocks[i];
                        if (b.state === 'ready') continue;

                        b.x += b.vx; b.y += b.vy;
                        b.vx *= 0.98; b.vy *= 0.98;

                        if (b.x <= 0) { b.x = 0; b.vx *= -0.6; }
                        if (b.x >= this.width - this.blockSize) { b.x = this.width - this.blockSize; b.vx *= -0.6; }
                        if (b.y <= 0) { b.y = 0; b.vy *= -0.6; }
                        
                        for (let j = i + 1; j < this.blocks.length; j++) {
                            let other = this.blocks[j];
                            if (this.checkCollision(b, other)) {
                                if (b.val === other.val) {
                                    this.merge(b, other);
                                    i--; break;
                                } else {
                                    this.resolveCollision(b, other);
                                }
                            }
                        }
                        
                        if (b.state !== 'ready' && Math.abs(b.vy) < 0.2 && Math.abs(b.vx) < 0.2) {
    if (b.state === 'moving') b.state = 'static'; // æ ‡è®°ä¸ºé™æ­¢
    
    // â–¼â–¼â–¼ ä¿®æ”¹åçš„åˆ¤å®šé€»è¾‘ â–¼â–¼â–¼
    if (b.y+ this.blockSize> this.limitY) { 
            document.getElementById('phy-overlay').classList.add('active');
            document.getElementById('phy-overlay-desc').innerText = `å †ç§¯è¿‡çº¿ï¼æœ€ç»ˆå¾—åˆ†: ${this.score}`;
            cancelAnimationFrame(this.animationId);
            return;
    }
    // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²
}
this.updateEl(b);
                    }
                }
                
                checkCollision(a, b) {
                    return (a.x < b.x + this.blockSize && a.x + this.blockSize > b.x && a.y < b.y + this.blockSize && a.y + this.blockSize > b.y);
                }

                resolveCollision(b1, b2) {
                    let cx1 = b1.x + this.blockSize/2, cy1 = b1.y + this.blockSize/2;
                    let cx2 = b2.x + this.blockSize/2, cy2 = b2.y + this.blockSize/2;
                    let dx = cx1 - cx2, dy = cy1 - cy2;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist === 0) { dx = 0.1; dist = 0.1; }
                    
                    let overlap = this.blockSize - dist;
                    if (overlap > 0) {
                        let nx = dx / dist, ny = dy / dist;
                        b1.x += nx * overlap * 0.5; b1.y += ny * overlap * 0.5;
                        b2.x -= nx * overlap * 0.5; b2.y -= ny * overlap * 0.5;
                        b1.vx += nx * 2; b1.vy += ny * 2;
                        b2.vx -= nx * 2; b2.vy -= ny * 2;
                    }
                }

                merge(target, source) {
                    target.val *= 2;
                    target.el.innerText = target.val;
                    target.el.className = `phy-block val-${target.val > 2048 ? 2048 : target.val}`;
                    target.el.style.transform = `scale(1.3)`;
                    setTimeout(() => target.el.style.transform = `scale(1)`, 150);
                    
                    source.el.remove();
                    this.blocks = this.blocks.filter(x => x !== source);
                    
                    this.updateScore(this.score + target.val);
                    if(window.audioManager) window.audioManager.playSFX();
                    target.vy = -5;
                }

                updateEl(b) {
                    b.el.style.left = b.x + 'px';
                    b.el.style.top = b.y + 'px';
                }
            }

            // --- 5. Gridæ¸¸æˆé€»è¾‘ ---
            class GridGame {
                constructor() {
                    this.grid = []; 
                    this.score = 0;
                    this.mode = 'classic';
                    this.size = 4;
                    this.isOver = false;
                    this.hp = 100;
                    this.maxHp = 100;
                    this.moves = 0;
                }

                start(mode) {
                    this.mode = mode;
                    this.size = CONFIG[mode].size;
                    document.getElementById('game-tip').innerText = CONFIG[mode].tip;
                    
                    document.getElementById('game-board-container').style.display = 'block';
                    document.getElementById('physics-stage').style.display = 'none';
                    
                    const board = document.getElementById('game-board');
                    board.style.setProperty('--grid-size', this.size);
                    
                    let fontSize = '35px';
                    if(this.size === 5) fontSize = '28px';
                    if(this.size === 6) fontSize = '22px';
                    board.style.setProperty('--tile-font-size', fontSize);
                    
                    this.hp = 100; this.moves = 50; this.score = 0;
                    
                    document.getElementById('hp-bar').style.display = (mode === 'rpg') ? 'block' : 'none';
                    document.getElementById('hp-text').style.display = (mode === 'rpg') ? 'block' : 'none';
                    document.getElementById('moves-box').style.display = (mode === 'ap') ? 'block' : 'none';

                    this.restart();
                }

                restart() {
                    this.grid = Array(this.size * this.size).fill(null);
                    this.isOver = false;
                    this.score = 0;
                    if(this.mode === 'rpg') this.hp = 100;
                    if(this.mode === 'ap') this.moves = 50;

                    document.getElementById('overlay').classList.remove('active');
                    this.updateUI();
                    this.spawnTile();
                    this.spawnTile();
                    this.render();
                }

                spawnTile(forceType = null) {
                    let empties = this.grid.map((c, i) => c === null ? i : null).filter(i => i !== null);
                    if (empties.length === 0) return;
                    if (this.mode === 'gravity') empties = empties.filter(idx => idx < this.size);
                    if (empties.length === 0) return;

                    const idx = empties[Math.floor(Math.random() * empties.length)];
                    let val = Math.random() < 0.9 ? 2 : 4;
                    let type = 'normal';

                    if (this.mode === 'rpg') {
                        let r = Math.random();
                        if (r < 0.2) { type = 'enemy'; val = Math.pow(2, Math.floor(Math.random()*3)+1); }
                        else if (r < 0.25) { type = 'potion'; val = 0; }
                    }
                    this.grid[idx] = { val, type, id: Math.random() };
                }

                move(dir) {
                    if (this.isOver) return;
                    if (this.mode === 'gravity' && dir === 1) return;

                    let moved = false;
                    let scoreGain = 0;
                    const getIdx = (r, c) => r * this.size + c;
                    
                    for (let i = 0; i < this.size; i++) {
                        let lineObj = [];
                        for (let j = 0; j < this.size; j++) {
                            let idx;
                            if (dir === 0) idx = getIdx(i, j);
                            else if (dir === 2) idx = getIdx(i, this.size - 1 - j);
                            else if (dir === 1) idx = getIdx(j, i);
                            else idx = getIdx(this.size - 1 - j, i);
                            lineObj.push(this.grid[idx]);
                        }

                        let processed = [];
                        let buffer = null;
                        let cells = lineObj.filter(c => c !== null);

                        for (let k = 0; k < cells.length; k++) {
                            let curr = cells[k];
                            if (!buffer) { buffer = curr; } 
                            else {
                                let res = this.interact(buffer, curr);
                                if (res.action === 'merge') {
                                    processed.push({ val: res.val, type: res.type || 'normal' });
                                    scoreGain += res.score;
                                    buffer = null;
                                    if(window.audioManager) window.audioManager.playSFX();
                                } else if (res.action === 'block') {
                                    processed.push(buffer);
                                    buffer = curr;
                                } else if (res.action === 'destroy') {
                                    if (res.val !== null) processed.push({ val: res.val, type: 'normal' });
                                    buffer = null;
                                    if(window.audioManager) window.audioManager.playSFX();
                                }
                            }
                        }
                        if (buffer) processed.push(buffer);
                        while (processed.length < this.size) processed.push(null);

                        for (let j = 0; j < this.size; j++) {
                            let targetIdx;
                            if (dir === 0) targetIdx = getIdx(i, j);
                            else if (dir === 2) targetIdx = getIdx(i, this.size - 1 - j);
                            else if (dir === 1) targetIdx = getIdx(j, i);
                            else targetIdx = getIdx(this.size - 1 - j, i);

                            let oldVal = this.grid[targetIdx];
                            let newVal = processed[j];
                            if (oldVal !== newVal) {
                                if (oldVal !== null || newVal !== null) {
                                     if (!oldVal || !newVal || oldVal.val !== newVal.val || oldVal.type !== newVal.type) moved = true;
                                }
                            }
                            this.grid[targetIdx] = newVal;
                        }
                    }

                    if (moved) {
                        this.score += scoreGain;

                        // 1. AP check
                        if (this.mode === 'ap') {
                            this.moves--;
                            if (scoreGain > 0) this.moves += Math.floor(scoreGain /8); 
                            if (this.moves <= 0) { this.endGame("è¡ŒåŠ¨åŠ›è€—å°½ï¼æŒ‘æˆ˜å¤±è´¥ï¼"); return; }
                        }

                        // 2. Win check
                        let maxVal = 0;
                        this.grid.forEach(cell => { if (cell && cell.val > maxVal) maxVal = cell.val; });
                        let target = 2048;
                        if (maxVal >= target) {
                            let winMsg = "æ­å–œï¼è¾¾æˆ 2048ï¼";
                            switch (this.mode) {
                                case 'city': winMsg = "æ­å–œé“å‹è¯æ— ä¸Šé“æœï¼Œä¿®æˆçœŸä»™ï¼"; break;
                                case 'rpg': winMsg = "ä¼ è¯´é­”ç‹å·²è¢«å‡»è´¥ï¼ä¸–ç•Œå’Œå¹³ï¼"; break;
                                case 'ap': winMsg = "åœ¨æ­¥æ•°è€—å°½å‰è¾¾æˆç›®æ ‡ï¼ç­–ç•¥å¤§å¸ˆï¼"; break;
                                case 'gravity': winMsg = "å¾æœäº†é‡åŠ›ï¼æŒ‘æˆ˜æˆåŠŸï¼"; break;
                                default: winMsg = "æ­å–œï¼ä½ åˆæˆäº† 2048ï¼"; break;
                            }
                            this.endGame(winMsg);
                            return;
                        }

                        // 3. Continue
                        this.spawnTile();
                        this.render();

                        // 4. Deadlock check
                        if (this.isGridFull() && !this.canMove()) {
                            if (this.mode === 'rpg') this.endGame("è¢«æ€ªç‰©åŒ…å›´äº†ï¼æ— æ³•ç§»åŠ¨ï¼");
                            else this.endGame("æ— æ³•ç§»åŠ¨äº†ï¼æ¸¸æˆç»“æŸï¼");
                        }
                    }
                }

                interact(a, b) {
                    if (b.type === 'potion') { this.heal(20); return { action: 'block', val: a.val }; }
                    if (a.type === 'potion') { this.heal(20); return { action: 'merge', val: b.val, type: b.type, score: 0 }; }
                    if (b.type === 'potion') { this.heal(20); return { action: 'merge', val: b.val, type: b.type, score: 0 }; }

                    if (this.mode === 'rpg') {
                        let hero = null, monster = null;
                        if (a.type !== 'enemy' && b.type === 'enemy') { hero = a; monster = b; }
                        else if (a.type === 'enemy' && b.type !== 'enemy') { hero = b; monster = a; }

                        if (hero && monster) {
                            if (hero.val >= monster.val) return { action: 'merge', val: hero.val * 2, type: 'normal', score: monster.val };
                            else { this.takeDamage(15); return { action: 'block' }; }
                        }
                        if (a.type === 'enemy' && b.type === 'enemy' && a.val === b.val) return { action: 'merge', val: a.val * 2, type: 'enemy', score: 0 };
                    }

                    if (a.val === b.val && a.type === b.type) return { action: 'merge', val: a.val * 2, type: a.type, score: a.val * 2 };
                    return { action: 'block' };
                }

                takeDamage(amount) {
                    this.hp = Math.max(0, this.hp - amount);
                    const board = document.getElementById('game-board');
                    board.style.animation = 'pulse 0.2s';
                    setTimeout(() => board.style.animation = '', 200);
                    if (this.hp <= 0) this.endGame("è‹±é›„ç‰ºç‰²äº†ï¼");
                    this.updateUI();
                }

                heal(amount) {
                    this.hp = Math.min(this.maxHp, this.hp + amount);
                    this.updateUI();
                }

                isGridFull() { return !this.grid.includes(null); }
                
                canMove() {
                    // 1. ç©ºä½
                    if (this.isGridFull() === false) return true;
                    // 2. æ£€æŸ¥å››å‘¨æ˜¯å¦æœ‰ç›¸åŒæ•°å­—
                    for (let i = 0; i < this.size; i++) {
                        for (let j = 0; j < this.size; j++) {
                            let idx = i * this.size + j;
                            let val = this.grid[idx].val; // æ³¨æ„è¿™é‡Œgridå­˜çš„æ˜¯å¯¹è±¡
                            // Right
                            if (j < this.size - 1) {
                                let right = this.grid[idx + 1].val;
                                if (val === right) return true;
                            }
                            // Down
                            if (i < this.size - 1) {
                                let bottom = this.grid[idx + this.size].val;
                                if (val === bottom) return true;
                            }
                        }
                    }
                    return false;
                }

                endGame(msg) {
                    this.isOver = true;
                    document.getElementById('overlay-msg').innerText = msg;
                    document.getElementById('overlay-desc').innerText = `æœ€ç»ˆå¾—åˆ†: ${this.score}`;
                    document.getElementById('overlay').classList.add('active');
                }

                updateUI() {
                    document.getElementById('score').innerText = this.score;
                    document.getElementById('moves').innerText = this.moves;
                    if (this.mode === 'rpg') {
                        const pct = (this.hp / this.maxHp) * 100;
                        document.getElementById('hp-fill').style.width = pct + "%";
                        document.getElementById('hp-text').innerText = `HP: ${this.hp}/${this.maxHp}`;
                    }
                }

                render() {
                    const board = document.getElementById('game-board');
                    const overlay = document.getElementById('overlay');
                    board.innerHTML = '';
                    board.appendChild(overlay);

                    this.grid.forEach(cell => {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        if (cell) {
                            const inner = document.createElement('div');
                            inner.className = `tile-inner val-${cell.val > 2048 ? 2048 : cell.val} type-${cell.type}`;
                            if (cell.type === 'potion') { inner.innerHTML = 'ğŸ’Š'; } 
                            else if (cell.type === 'enemy') {
                                inner.innerHTML = 'ğŸ’€<br>' + cell.val;
                                inner.style.flexDirection = 'column';
                                inner.style.fontSize = 'calc(var(--tile-font-size) * 0.6)';
                            } else if (this.mode === 'city' && cell.type === 'normal') {
                                inner.innerText = CITY_NAMES[cell.val] || cell.val;
                                inner.style.fontSize = this.size > 5 ? '12px' : '16px';
                            } else {
                                inner.innerText = cell.val;
                            }
                            tile.appendChild(inner);
                        }
                        board.appendChild(tile);
                    });
                    this.updateUI();
                }
            }

            // --- 6. å…¨å±€åˆå§‹åŒ– ---
            window.audioManager = new AudioManager();
            const gridGame = new GridGame();
            const physicsGame = new PhysicsGame();

            window.game = {
                start: (mode) => {
                    document.getElementById('start-screen').classList.add('hidden');
                    document.getElementById('game-screen').classList.remove('hidden');
                    if (mode === 'shoot') physicsGame.start();
                    else gridGame.start(mode);
                },
                showMenu: () => {
                    document.getElementById('start-screen').classList.remove('hidden');
                    document.getElementById('game-screen').classList.add('hidden');
                    if (physicsGame.animationId) cancelAnimationFrame(physicsGame.animationId);
                },
                restartGrid: () => gridGame.restart(),
                restartPhysics: () => physicsGame.restart()
            };

            // é”®ç›˜äº‹ä»¶
            document.addEventListener('keydown', e => {
                if (document.getElementById('physics-stage').style.display === 'block') return;
                if (document.getElementById('game-screen').classList.contains('hidden')) return;

                if (e.key === 'ArrowLeft') gridGame.move(0);
                else if (e.key === 'ArrowUp') gridGame.move(1);
                else if (e.key === 'ArrowRight') gridGame.move(2);
                else if (e.key === 'ArrowDown') gridGame.move(3);
            });

            // è§¦æ‘¸äº‹ä»¶
            let tx = 0, ty = 0;
            const boardEl = document.getElementById('game-board');
           boardEl.addEventListener('touchstart', e => { 
    // æ–°å¢ï¼šå¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®ï¼Œæˆ–è€…æ˜¯è¦†ç›–å±‚é‡Œçš„å…ƒç´ ï¼Œç›´æ¥è¿”å›ï¼Œå…è®¸è§¦å‘ç‚¹å‡»
    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
        return; 
    }

    tx = e.touches[0].clientX; 
    ty = e.touches[0].clientY; 
    
    // åªæœ‰åœ¨éæŒ‰é’®åŒºåŸŸæ‰é˜»æ­¢é»˜è®¤æ»šåŠ¨
    if(e.cancelable) e.preventDefault(); 
}, {passive: false});
            boardEl.addEventListener('touchmove', e => { e.preventDefault(); }, {passive: false});
            boardEl.addEventListener('touchend', e => {
                let dx = e.changedTouches[0].clientX - tx;
                let dy = e.changedTouches[0].clientY - ty;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (Math.abs(dx) > 30) gridGame.move(dx > 0 ? 2 : 0);
                } else {
                    if (Math.abs(dy) > 30) gridGame.move(dy > 0 ? 3 : 1);
                }
            });
        });
    </script>
</body>
</html>